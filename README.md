# Calculator
<<<<<<< HEAD
表达式计算器的设计与实现

## 一、	字符集定义

1. <字符> → <数字>│<单界符>│.
2. <数字> → 0│<非零数字>
3. <非零数字>→ 1│2│…│9
4. <单界符> →<运算符>│(│)
5. <运算符> → +│-│*│/

## 二、	单词集定义

1. <单词> → <单界符>│<常数>
2. <常数> → <无符号整数>│<无符号浮点数>
3. <无符号整数> →0│<非零整数>
4. <非零整数> → <非零数字> <数字串>
5. <数字串> → <数字> <数字串>│NULL
6. <无符号浮点数> →<无符号整数>. <数字> <数字串>

## 三、	数据类型定义

1. <类型> → int│double

## 四、	表达式定义

1. E<算术表达式> → T <项> + E <算术表达式>│T <项> - E <算术表达式>│T<项>
2. T<项> → F <因子> * T <项>│F <因子> / T <项>│F <因子>
3. F<因子> → i<常数>│（ E<算术表达式> ）│- F <因子> 

## 五、	表达式计算器的单词编码

| 种别码 | 单词         |
| :----- | :----------- |
| 1      | +            |
| 2      | -            |
| 3      | *            |
| 4      | /            |
| 5      | (            |
| 6      | )            |
| 7      | 无符号整数   |
| 8      | 无符号浮点数 |

## 具体设计

先对输入串进行词法分析，通过遍历查看是否有不合法的字符，如果有非法字符的话指出对应的位置，而如果都合法的话则生成相应的四元式，并继续进行语法分析。先根据文法构建活前缀的DFA，再根据DFA构造动作表（ACTION）和转换表（GOTO），根据分析栈的栈顶状态和输入串的当前符号查分析表确定应采取的动作（移进、归约、接受或报错），对状态栈和符号栈进行相应的操作。具体操作：

1. 若ACTION[S,a]=Sj，a为终结符，则把a移入符号栈，j移入状态栈；
2. 若ACTION[S,a]=rj，a为终结符或＃，则用第j个产生式（A->β ）归约，将两个栈弹出k个元素，其中k为第j个产生式右部符号串长度，这时当前面临符号为第j个产生式左部的非终结符（A）；若状态栈当前的栈顶状态为Sk，且GOTO[Sk,A]=j，则非终结符A移入符号栈，j移入状态栈；
3. 若ACTION[S,a]=acc,a为＃，则为接受，表明分析成功；
4. 若ACTION[S,a]=空白，则转向出错处理。

最后分析成功的话输出表达式的运算结果。
>>>>>>> 小修改
